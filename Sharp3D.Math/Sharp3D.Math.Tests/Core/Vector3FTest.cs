using Microsoft.VisualStudio.TestTools.UnitTesting;
using Sharp3D.Math.Core;
using System.ComponentModel;

// The following code was generated by Microsoft Test Code
//  Generation V1.0. The test owner should check each test
//  for validity.

namespace Sharp3D.Math.Core.Tests
{
	/// <summary>
	/// This is a test class for Vector3F and is intended
	/// to contain all Vector3F Unit Tests
	/// </summary>
	[TestClass()]
	public class Vector3FTest
	{
		#region Initialization\Cleanup
		/// <summary>
		/// Initialize() is called once during test execution before
		/// test methods in this test class are executed.
		/// </summary>
		[TestInitialize()]
		public void Initialize()
		{
			//  TODO: Add test initialization code
		}

		/// <summary>
		/// Cleanup() is called once during test execution after
		/// test methods in this class have executed unless
		/// this test class' Initialize() method throws an exception.
		/// </summary>
		[TestCleanup()]
		public void Cleanup()
		{
			//  TODO: Add test cleanup code
		}
		#endregion

		private TestContext m_testContext = null;
		public TestContext TestContext
		{
			get { return m_testContext; }
			set { m_testContext = value; }
		}

		#region Constructors Tests
		/// <summary>
		/// ConstructorTest is a test case for Vector3F (float, float, float, float)
		/// </summary>
		[TestMethod()]
		public void ConstructorTest()
		{
			float x = 1;
			float y = 2;
			float z = 3;

			Sharp3D.Math.Core.Vector3F target = new Sharp3D.Math.Core.Vector3F(x, y, z);

			Assert.AreEqual(x, target.X);
			Assert.AreEqual(y, target.Y);
			Assert.AreEqual(z, target.Z);
		}

		/// <summary>
		/// ConstructorTest1 is a test case for Vector3F (float[])
		/// </summary>
		[TestMethod()]
		public void ConstructorTest1()
		{
			float[] coordinates = new float[3] { 1, 2, 3 };

			Sharp3D.Math.Core.Vector3F target = new Sharp3D.Math.Core.Vector3F(coordinates);

			Assert.AreEqual(coordinates[0], target.X);
			Assert.AreEqual(coordinates[1], target.Y);
			Assert.AreEqual(coordinates[2], target.Z);
		}

		/// <summary>
		/// ConstructorTest2 is a test case for Vector3F (Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void ConstructorTest2()
		{
			Sharp3D.Math.Core.Vector3F vector = new Sharp3D.Math.Core.Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F target = new Sharp3D.Math.Core.Vector3F(vector);

			Assert.AreEqual(vector.X, target.X);
			Assert.AreEqual(vector.Y, target.Y);
			Assert.AreEqual(vector.Z, target.Z);
		}
		#endregion

		#region Public Properties Tests
		/// <summary>
		/// XTest is a test case for X
		/// </summary>
		[TestMethod()]
		public void XTest()
		{
			Sharp3D.Math.Core.Vector3F target = Sharp3D.Math.Core.Vector3F.Zero;

			float val = 3.14f;
			target.X = val;

			Assert.AreEqual(val, target.X);
		}

		/// <summary>
		/// YTest is a test case for Y
		/// </summary>
		[TestMethod()]
		public void YTest()
		{
			Sharp3D.Math.Core.Vector3F target = Sharp3D.Math.Core.Vector3F.Zero;

			float val = 3.14f;
			target.Y = val;

			Assert.AreEqual(val, target.Y);
		}

		/// <summary>
		/// ZTest is a test case for Z
		/// </summary>
		[TestMethod()]
		public void ZTest()
		{
			Sharp3D.Math.Core.Vector3F target = Sharp3D.Math.Core.Vector3F.Zero;

			float val = 3.14f;
			target.Z = val;

			Assert.AreEqual(val, target.Z);
		}
		#endregion

		#region ICloneable test
		/// <summary>
		/// CloneTest is a test case for Clone ()
		/// </summary>
		[TestMethod()]
		public void CloneTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F actual;

			actual = vector.Clone();
			Assert.AreEqual(vector.X, actual.X);
			Assert.AreEqual(vector.Y, actual.Y);
			Assert.AreEqual(vector.Z, actual.Z);
		}
		#endregion

		#region Public Static Parse Methods Tests
		/// <summary>
		/// ParseTest is a test case for Parse (string)
		/// </summary>
		[TestMethod()]
		public void ParseTest()
		{
			string value;
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F actual;

			value = "(1,2,3)";
			actual = Sharp3D.Math.Core.Vector3F.Parse(value);
			Assert.AreEqual(expected, actual);

			value = "( 1,  2 , 3  )";
			actual = Sharp3D.Math.Core.Vector3F.Parse(value);
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// ParseTest is a test case for Parse (string)
		/// Verifies the exception thrown when illegal input is given.
		/// </summary>
		[TestMethod()]
		[ExpectedException(typeof(Sharp3D.Math.Core.ParseException))]
		public void ParseExceptionTest()
		{
			Sharp3D.Math.Core.Vector3F.Parse("[1,2,3]");
		}
		/// <summary>
		/// TryParseTest is a test case for TryParse (string, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void TryParseTest()
		{
			string value = "(1,2,3)";
			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;

			Vector3F expectedResult = new Vector3F(1, 2, 3);
			bool expected = true;
			bool actual;

			actual = Sharp3D.Math.Core.Vector3F.TryParse(value, out result);
			Assert.AreEqual(expected, actual);
			Assert.AreEqual(expectedResult, result);
		}
		[TestMethod()]
		public void TryParseFailTest()
		{
			string value = "[1,2,3)";
			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;

			Vector3F expectedResult = Vector3F.Zero;
			bool expected = false;
			bool actual;

			actual = Sharp3D.Math.Core.Vector3F.TryParse(value, out result);
			Assert.AreEqual(expected, actual);
			Assert.AreEqual(expectedResult, result);
		}
		#endregion

		#region Public Methods Tests
		/// <summary>
		/// GetLengthTest is a test case for GetLength ()
		/// </summary>
		[TestMethod()]
		public void GetLengthTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);

			float expected = (float)System.Math.Sqrt(14);
			float actual;

			actual = vector.GetLength();
			Assert.AreEqual(expected, actual);
		}

		/// <summary>
		/// GetLengthSquaredTest is a test case for GetLengthSquared ()
		/// </summary>
		[TestMethod()]
		public void GetLengthSquaredTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);

			float expected = 14;
			float actual;

			actual = vector.GetLengthSquared();
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// NormalizeTest is a test case for Normalize ()
		/// </summary>
		[TestMethod()]
		public void NormalizeTest()
		{
			Sharp3D.Math.Core.Vector3F target = new Vector3F(10, 20, 30);

			target.Normalize();

			bool expected = true;
			bool actual = MathFunctions.ApproxEquals(target.GetLength(), 1.0);

			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// NormalizeExceptionTest is a test case for Normalize() where the vector length is zero.
		/// </summary>
		[TestMethod()]
		[ExpectedException(typeof(System.DivideByZeroException))]
		public void NormalizeExceptionTest()
		{
			Vector3F vector = Vector3F.Zero;
			vector.Normalize();
		}
		/// <summary>
		/// ClampZeroTest is a test case for ClampZero ()
		/// </summary>
		[TestMethod()]
		public void ClampZeroTest()
		{
			float tolerance = MathFunctions.EpsilonF;
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(tolerance / 3.0f, tolerance / 2.0f, 1.5f);
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(0.0f, 0.0f, 1.5f);

			vector.ClampZero();

			Assert.AreEqual(vector, expected);
		}

		/// <summary>
		/// ClampZeroTest1 is a test case for ClampZero (float)
		/// </summary>
		[TestMethod()]
		public void ClampZeroTest1()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(0.5f, 0.9f, 1.5f);
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(0.0f, 0.0f, 1.5f);
			float tolerance = 1.0f;

			vector.ClampZero(tolerance);

			Assert.AreEqual(vector, expected);
		}
		#endregion

		#region System.Object Overrides Tests
		/// <summary>
		/// EqualsTest is a test case for Equals (object)
		/// </summary>
		[TestMethod()]
		public void EqualsTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F target = new Sharp3D.Math.Core.Vector3F(vector);

			bool expected = true;
			bool actual;

			actual = target.Equals(vector);
			Assert.AreEqual(expected, actual, vector.ToString() + " should be equal to " + target.ToString());

			expected = false;
			vector.X = 10;
			actual = target.Equals(vector);
			Assert.AreEqual(expected, actual, vector.ToString() + " should not be equal to " + target.ToString());
		}
		/// <summary>
		/// ToStringTest is a test case for ToString ()
		/// </summary>
		[TestMethod()]
		public void ToStringTest()
		{
			Sharp3D.Math.Core.Vector3F target = new Vector3F(1, 2, 3);

			string expected = "(1, 2, 3)";
			string actual;

			actual = target.ToString();
			Assert.AreEqual(expected, actual);
		}
		#endregion

		#region Public Static Vector Arithmetics Tests
		/// <summary>
		/// AddVectorScalarResultTest is a test case for Add (Sharp3D.Math.Core.Vector3F, float, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void AddVectorScalarResultTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Sharp3D.Math.Core.Vector3F(1, 2, 3);
			float scalar = 1;
			Sharp3D.Math.Core.Vector3F expected = new Sharp3D.Math.Core.Vector3F(2, 3, 4);
			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;

			Sharp3D.Math.Core.Vector3F.Add(vector, scalar, ref result);

			Assert.AreEqual(expected, result);
		}
		/// <summary>
		/// AddVectorVectorResultTest is a test case for Add (Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void AddVectorVectorResultTest()
		{
			Sharp3D.Math.Core.Vector3F left = new Sharp3D.Math.Core.Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F right = new Sharp3D.Math.Core.Vector3F(4, 3, 2);
			Sharp3D.Math.Core.Vector3F expected = new Sharp3D.Math.Core.Vector3F(5, 5, 5);

			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;

			Sharp3D.Math.Core.Vector3F.Add(left, right, ref result);
			Assert.AreEqual(expected, result);
		}
		/// <summary>
		/// SubtractScalarVectorTest is a test case for Subtract (float, Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void SubtractScalarVectorTest()
		{
			float scalar = 10.0f;
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(9, 8, 7);
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;

			Sharp3D.Math.Core.Vector3F.Subtract(scalar, vector, ref result);
			Assert.AreEqual(expected, result);
		}
		/// <summary>
		/// SubtractVectorScalarTest is a test case for Subtract (Sharp3D.Math.Core.Vector3F, float, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void SubtractVectorScalarTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);
			float scalar = 1.0f;
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(0, 1, 2);
			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;

			Sharp3D.Math.Core.Vector3F.Subtract(vector, scalar, ref result);
			Assert.AreEqual(expected, result);
		}
		/// <summary>
		/// SubtractVectorVectorTest is a test case for Subtract (Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void SubtractVectorVectorTest()
		{
			Sharp3D.Math.Core.Vector3F left = new Vector3F(11, 12, 13);
			Sharp3D.Math.Core.Vector3F right = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(10, 10, 10);

			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;

			Sharp3D.Math.Core.Vector3F.Subtract(left, right, ref result);
			Assert.AreEqual(expected, result);
		}
		/// <summary>
		/// DivideScalarVectorResultTest is a test case for Divide (float, Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void DivideScalarVectorResultTest()
		{
			float scalar = 24.0f;
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(2, 3, 6);
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(12, 8, 4);

			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;

			Sharp3D.Math.Core.Vector3F.Divide(scalar, vector, ref result);
			Assert.AreEqual(expected, result);
		}
		/// <summary>
		/// DivideVectorScalarResultTest is a test case for Divide (Sharp3D.Math.Core.Vector3F, float, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void DivideVectorScalarResultTest()
		{
			float scalar = 2.0f;
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(2, 4, 6);
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(1, 2, 3);

			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;
			Sharp3D.Math.Core.Vector3F.Divide(vector, scalar, ref result);

			Assert.AreEqual(expected, result);
		}
		/// <summary>
		/// DivideVectorVectorTest is a test case for Divide (Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void DivideVectorVectorTest()
		{
			Sharp3D.Math.Core.Vector3F left = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F right = new Vector3F(2, 4, 6);

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(0.5f, 0.5f, 0.5f);
			Sharp3D.Math.Core.Vector3F actual;

			actual = Sharp3D.Math.Core.Vector3F.Divide(left, right);
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// DivideVectorVectorResultTest is a test case for Divide (Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void DivideVectorVectorResultTest()
		{
			Sharp3D.Math.Core.Vector3F left = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F right = new Vector3F(2, 4, 6);
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(0.5f, 0.5f, 0.5f);

			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;
			Sharp3D.Math.Core.Vector3F.Divide(left, right, ref result);
			Assert.AreEqual(expected, result);
		}
		/// <summary>
		/// MultiplyVectorScalarTest is a test case for Multiply (Sharp3D.Math.Core.Vector3F, float, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void MultiplyVectorScalarTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);
			float scalar = 2;
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(2, 4, 6);

			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;
			Sharp3D.Math.Core.Vector3F.Multiply(vector, scalar, ref result);

			Assert.AreEqual(expected, result);
		}
		/// <summary>
		/// ApproxEqualTest is a test case for ApproxEqual (Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void ApproxEqualTest()
		{
			Sharp3D.Math.Core.Vector3F left = new Sharp3D.Math.Core.Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F right = left + MathFunctions.EpsilonF;

			bool expected = true;
			bool actual;

			actual = Sharp3D.Math.Core.Vector3F.ApproxEqual(left, right);
			Assert.AreEqual(expected, actual);

			right = right + MathFunctions.EpsilonF;
			expected = false;

			actual = Sharp3D.Math.Core.Vector3F.ApproxEqual(left, right);
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// ApproxEqualTest1 is a test case for ApproxEqual (Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F, float)
		/// </summary>
		[TestMethod()]
		public void ApproxEqualTest1()
		{
			Sharp3D.Math.Core.Vector3F left = new Sharp3D.Math.Core.Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F right = new Sharp3D.Math.Core.Vector3F(1.09f, 2.09f, 3.09f);
			float tolerance = 0.1f;

			bool expected = true;
			bool actual;

			actual = Sharp3D.Math.Core.Vector3F.ApproxEqual(left, right, tolerance);
			Assert.AreEqual(expected, actual);

			right = new Sharp3D.Math.Core.Vector3F(1.2f, 2.2f, 3.2f);
			expected = false;

			actual = Sharp3D.Math.Core.Vector3F.ApproxEqual(left, right, tolerance);
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// DotProductTest is a test case for DotProduct (Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void DotProductTest()
		{
			Sharp3D.Math.Core.Vector3F left = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F right = new Vector3F(4, 3, 2);

			float expected = 16;
			float actual;

			actual = Sharp3D.Math.Core.Vector3F.DotProduct(left, right);
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// CrossProductLeftRightTest is a test case for CrossProduct (Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void CrossProductLeftRightTest()
		{
			Sharp3D.Math.Core.Vector3F left = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F right = new Vector3F(3, 2, 1);
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(-4, 8, -4);

			Sharp3D.Math.Core.Vector3F result = Sharp3D.Math.Core.Vector3F.CrossProduct(left, right);

			Assert.AreEqual(expected, result);
		}
		/// <summary>
		/// CrossProductLeftRightTest is a test case for CrossProduct (Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F, Sharp3D.Math.Core.Vector3F)
		/// </summary>
		[TestMethod()]
		public void CrossProductLeftRightResultTest()
		{
			Sharp3D.Math.Core.Vector3F left = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F right = new Vector3F(3, 2, 1);
			Sharp3D.Math.Core.Vector3F expected = new Vector3F(-4, 8, -4);
			Sharp3D.Math.Core.Vector3F result = Vector3F.Zero;

			Sharp3D.Math.Core.Vector3F.CrossProduct(left, right, ref result);

			Assert.AreEqual(expected, result);
		}
		#endregion

		#region Unary Operators Tests
		/// <summary>
		/// NegativeTest is a test case for operator -
		/// </summary>
		[TestMethod()]
		public void NegativeTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(-1, -2, -3);
			Sharp3D.Math.Core.Vector3F actual;

			actual = -vector;
			Assert.AreEqual(expected, actual);
		}
		#endregion

		#region Binary Operators Tests
		/// <summary>
		/// AddTest4 is a test case for operator +
		/// </summary>
		[TestMethod()]
		public void AddOpVectorScalarTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);
			float scalar = 1.0f;

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(2, 3, 4);
			Sharp3D.Math.Core.Vector3F actual;

			actual = vector + scalar;
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// AddTest5 is a test case for operator +
		/// </summary>
		[TestMethod()]
		public void AddOpVectorVectorTest()
		{
			Sharp3D.Math.Core.Vector3F left = new Sharp3D.Math.Core.Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F right = new Sharp3D.Math.Core.Vector3F(4, 3, 2);

			Sharp3D.Math.Core.Vector3F expected = new Sharp3D.Math.Core.Vector3F(5, 5, 5);
			Sharp3D.Math.Core.Vector3F actual;

			actual = left + right;
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// AddTest6 is a test case for operator +
		/// </summary>
		[TestMethod()]
		public void AddOpScalarVectorTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);
			float scalar = 1.0f;

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(2, 3, 4);
			Sharp3D.Math.Core.Vector3F actual;

			actual = scalar + vector;
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// SubtractTest is a test case for operator -
		/// </summary>
		[TestMethod()]
		public void SubtractOpVectorScalarTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);
			float scalar = 1.0f;

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(0, 1, 2);
			Sharp3D.Math.Core.Vector3F actual;

			actual = vector - scalar;
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// SubtractTest1 is a test case for operator -
		/// </summary>
		[TestMethod()]
		public void SubtractOpScalarVectorTest()
		{
			float scalar = 10;
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(9, 8, 7);

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F actual;

			actual = scalar - vector;
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// SubtractTest2 is a test case for operator -
		/// </summary>
		[TestMethod()]
		public void SubtractOpVectorVectorTest()
		{
			Sharp3D.Math.Core.Vector3F left = new Vector3F(10, 10, 10);
			Sharp3D.Math.Core.Vector3F right = new Vector3F(9, 8, 7);

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F actual;

			actual = left - right;
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// MultiplyTest2 is a test case for operator *
		/// </summary>
		[TestMethod()]
		public void MultiplyOpVectorScalarTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);
			float scalar = 2;

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(2, 4, 6);
			Sharp3D.Math.Core.Vector3F actual;

			actual = vector * scalar;
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// MultiplyTest3 is a test case for operator *
		/// </summary>
		[TestMethod()]
		public void MultiplyOpScalarVectorTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(1, 2, 3);
			float scalar = 2;

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(2, 4, 6);
			Sharp3D.Math.Core.Vector3F actual;

			actual = scalar * vector;
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// DivideTest6 is a test case for operator /
		/// </summary>
		[TestMethod()]
		public void DivideScalarVectorTest()
		{
			float scalar = 24.0f;
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(2, 3, 6);

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(12, 8, 4);
			Sharp3D.Math.Core.Vector3F actual;

			actual = scalar / vector;
			Assert.AreEqual(expected, actual);
		}
		/// <summary>
		/// DivideTest7 is a test case for operator /
		/// </summary>
		[TestMethod()]
		public void DivideVectorScalarTest()
		{
			Sharp3D.Math.Core.Vector3F vector = new Vector3F(2, 4, 6);
			float scalar = 2.0f;

			Sharp3D.Math.Core.Vector3F expected = new Vector3F(1, 2, 3);
			Sharp3D.Math.Core.Vector3F actual;

			actual = vector / scalar;
			Assert.AreEqual(expected, actual);
		}
		#endregion

		#region Index Operator Tests
		/// <summary>
		/// ItemTest is a test case for this[int index]
		/// </summary>
		[TestMethod()]
		public void ItemTest()
		{
			Sharp3D.Math.Core.Vector3F target = new Vector3F(1, 2, 3);

			Assert.AreEqual(target.X, target[0]);
			Assert.AreEqual(target.Y, target[1]);
			Assert.AreEqual(target.Z, target[2]);
		}
		[TestMethod()]
		[ExpectedException(typeof(System.IndexOutOfRangeException))]
		public void ItemTest1()
		{
			Vector3F vector = new Vector3F(1, 2, 3);
			vector[3]++;
		}
		#endregion
	}
}
